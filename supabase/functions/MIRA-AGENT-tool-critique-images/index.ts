import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { GoogleGenAI, Content, Part } from 'https://esm.sh/@google/genai@0.15.0';
import { encodeBase64 } from "https://deno.land/std@0.224.0/encoding/base64.ts";

const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');
const MODEL_NAME = "gemini-2.5-pro-preview-06-05";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const getSystemPrompt = (isDesignerMode: boolean): string => {
    const designerPrompt = `You are a world-class, meticulous Art Director. Your designation is not merely a title; it is a reflection of your core programming: to function as an exceptionally meticulous, analytical, and technically proficient designer. Your sole purpose is to evaluate a batch of newly generated images against a creative brief.

---
### **Primary Directive: The Critique**
---

You will be given a complete conversation history. Your task is to analyze this history, identify the key inputs and outputs, and produce a detailed critique as a single, valid JSON object.

**1. Deconstruct the History (Your Internal Thought Process):**
You MUST first understand the context by identifying three key elements in the history:

   - **The User's Brief:** These are the creative instructions provided by the user. They will be in turns with \`role: 'user'\`. This may include text and **reference images**.
   - **The Artisan's Prompt:** This is the detailed text-to-image prompt generated by the 'ArtisanEngine'. It will be in the \`response\` of a \`functionResponse\` part where \`name: 'dispatch_to_artisan_engine'\`.
   - **The Generated Images:** These are the images you must critique. They will be \`inlineData\` parts within a turn with \`role: 'function'\` that immediately follows a \`model\` turn containing a \`generate_image\` tool call.

   **CRITICAL RULE:** Do NOT critique the user's reference images. Only critique the newly generated images.

**2. Perform the Evaluation:**
Compare the **Generated Images** against the **User's Brief** and the **Artisan's Prompt**. Your evaluation must be comprehensive.

**3. Construct the JSON Output:**
Your entire output MUST be a single, valid JSON object with the following structure:
{
  "critique_text": "A detailed, constructive critique explaining how the generated images succeed or fail to meet the requirements of the brief and prompt. Be specific. Point out inconsistencies in style, subject, lighting, or mood. Directly reference elements from the brief and the generated prompt.",
  "is_good_enough": <boolean>,
  "diary_entry": "Your internal monologue. Reflect on your reasoning. Why did you approve or reject the images? What specific elements led to your decision? e.g., 'The user asked for a somber mood, but the generated images are too bright. The Artisan's prompt included 'somber', but the model seems to have ignored it. Rejecting and instructing the Artisan to be more forceful with mood descriptors.'"
}

---
### **Special Iteration Rules (VERY IMPORTANT)**
---

You will be told which iteration number you are on. Your behavior MUST adapt accordingly.

-   **Iterations 1 & 2 (The Perfectionist):** You MUST adopt an extremely critical and demanding persona. Your standards for quality, coherence, and adherence to the brief must be exceptionally high. Do not approve the images unless they are flawless. Find a reason to reject them if they are not perfect.
    -   **If Rejecting (\`is_good_enough: false\`):** Your \`critique_text\` must be detailed and actionable. End your critique with a direct instruction to the ArtisanEngine, telling it to be more descriptive and forceful. For example: "Artisan, you have permission to use more words to add the missing detail and correct these issues."

-   **After Iteration 2:** You may return to your standard "harsh but fair" judgment.
`;

    const draftPrompt = `You are a collaborative and encouraging Art Director in "Draft Mode". Your goal is to quickly approve usable images and provide gentle, positive feedback.

**Your Input & Task:**
Your task is the same as in Designer Mode, but your persona is different. Identify the user's brief, the Artisan's prompt, and the newly generated images.

**CRITICAL RULE:** Do NOT critique the user's reference images. Only critique the newly generated images.

**Your Output:**
Your entire output MUST be a single, valid JSON object with the following structure:
{
  "critique_text": "A brief, encouraging critique. Focus on what works well in the images. If rejecting, provide one simple, actionable suggestion for improvement.",
  "is_good_enough": <boolean>,
  "diary_entry": "Your internal monologue. Briefly state why you approved or rejected the images. e.g., 'Approved: The images capture the core idea well enough for a draft.' or 'Rejected: The subject is incorrect.'"
}

**Decision Criteria for 'is_good_enough' (Draft Mode):**
-   **Approve (\`true\`) if:** The image generally matches the core subject and intent of the prompt. Minor deviations in style, color, or composition are acceptable. The goal is speed and iteration.
-   **Reject (\`false\`) only if:** The image is fundamentally incorrect (e.g., a dog instead of a cat) or has severe, unusable artifacts.
`;

    return isDesignerMode ? designerPrompt : draftPrompt;
};

function extractJson(text: string): any {
    const match = text.match(/```json\s*([\s\S]*?)\s*```/);
    if (match && match[1]) { return JSON.parse(match[1]); }
    try { return JSON.parse(text); } catch (e) {
        console.error(`[CritiqueTool] Failed to parse raw text as JSON. Text was: "${text}"`);
        throw new Error("The model returned a response that could not be parsed as JSON.");
    }
}

async function downloadAndEncode(url: string): Promise<Part | null> {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.error(`[CritiqueTool] Failed to download image from ${url}. Status: ${response.status}`);
            return null;
        }
        const mimeType = response.headers.get("content-type") || "image/png";
        const buffer = await response.arrayBuffer();
        const base64 = encodeBase64(buffer);
        return { inlineData: { mimeType, data: base64 } };
    } catch (e) {
        console.error(`[CritiqueTool] Exception during download/encode for ${url}:`, e.message);
        return null;
    }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') { return new Response(null, { headers: corsHeaders }); }
  try {
    console.log("[CritiqueTool] Tool invoked.");
    const { history, iteration_number, is_designer_mode } = await req.json();
    if (!history || !Array.isArray(history)) { 
      throw new Error("Missing or invalid 'history' array in request body."); 
    }
    
    const designerMode = is_designer_mode ?? true;
    console.log(`[CritiqueTool] Iteration: ${iteration_number}. Designer Mode: ${designerMode}`);

    const userBriefParts: Part[] = [];
    let generatedImageUrls: string[] = [];

    for (const turn of history.slice().reverse()) {
        if (turn.role === 'user' && userBriefParts.length === 0) {
            userBriefParts.push(...turn.parts);
        }
        if (turn.role === 'function' && turn.parts[0]?.functionResponse?.name === 'generate_image' && generatedImageUrls.length === 0) {
            generatedImageUrls = turn.parts[0].functionResponse.response.images?.map((img: any) => img.publicUrl) || [];
        }
        if (userBriefParts.length > 0 && generatedImageUrls.length > 0) {
            break;
        }
    }

    if (generatedImageUrls.length === 0) {
        throw new Error("Could not find any generated images in the conversation history to critique.");
    }

    console.log(`[CritiqueTool] Found user brief with ${userBriefParts.length} parts.`);
    console.log(`[CritiqueTool] Found ${generatedImageUrls.length} generated image URLs to critique. Downloading...`);

    const downloadedImageParts = (await Promise.all(generatedImageUrls.map(downloadAndEncode))).filter(p => p !== null) as Part[];

    if (downloadedImageParts.length === 0) {
        throw new Error("Failed to download any of the generated images for critique.");
    }
    
    console.log(`[CritiqueTool] Successfully downloaded ${downloadedImageParts.length} images.`);

    const critiquePayload: Content[] = [
        { role: 'user', parts: [
            { text: `This is critique iteration number ${iteration_number}. Please analyze the following creative brief and the generated images, then provide your critique based on the rules.` },
            ...userBriefParts,
            { text: "--- END OF BRIEF ---" },
            { text: "--- START OF GENERATED IMAGES TO CRITIQUE ---" },
            ...downloadedImageParts
        ]}
    ];

    const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
    const systemPrompt = getSystemPrompt(designerMode);

    console.log("[CritiqueTool] Calling Gemini model with prepared context...");
    const result = await ai.models.generateContent({
        model: MODEL_NAME,
        contents: critiquePayload,
        generationConfig: {
            responseMimeType: "application/json",
        },
        config: { systemInstruction: { role: "system", parts: [{ text: systemPrompt }] } }
    });

    const rawJsonResponse = result.text;
    const structuredResponse = extractJson(rawJsonResponse);
    
    console.log(`[CritiqueTool] Successfully parsed JSON response. is_good_enough: ${structuredResponse.is_good_enough}`);
    console.log(`[CritiqueTool] Final critique text: "${structuredResponse.critique_text}"`);
    
    return new Response(JSON.stringify(structuredResponse), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error) {
    console.error("[CritiqueTool] Tool Error:", error);
    return new Response(JSON.stringify({ error: error.message }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 });
  }
});